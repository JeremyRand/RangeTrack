#define M_PI 3.1415926535897932384626433832795028841971

#include "RangeTrackAnalyzer.h"
#include "math.h"
#include "stdlib.h"

RangeTrackAnalyzer::RangeTrackAnalyzer(RangeTrackPositionReader *position_reader_x, RangeTrackPositionReader *position_reader_y, RangeTrackPositionReader *position_reader_theta, RangeTrackRangeReader *range_reader, RangeTrackFilter *range_filter, RangeTrackFilter *slope_filter, RangeTrackFilter *concavity_filter)
: RangeTrackSegmenter(position_reader_x, position_reader_y, position_reader_theta, range_reader, range_filter, slope_filter, concavity_filter)
{
    m_wall_rotation = 0.0;
}

int RangeTrackAnalyzer::GetSegmentStartPositionX(int segment)
{
    return m_x_positions[m_segments[segment].GetStartIndex()];
}

int RangeTrackAnalyzer::GetSegmentStartPositionY(int segment)
{
    return m_y_positions[m_segments[segment].GetStartIndex()];
}

int RangeTrackAnalyzer::GetSegmentStartPositionTheta(int segment)
{
    return m_theta_positions[m_segments[segment].GetStartIndex()];
}

int RangeTrackAnalyzer::GetSegmentEndPositionX(int segment)
{
    return m_x_positions[m_segments[segment].GetEndIndex()];
}

int RangeTrackAnalyzer::GetSegmentEndPositionY(int segment)
{
    return m_y_positions[m_segments[segment].GetEndIndex()];
}

int RangeTrackAnalyzer::GetSegmentEndPositionTheta(int segment)
{
    return m_theta_positions[m_segments[segment].GetEndIndex()];
}

int RangeTrackAnalyzer::GetSegmentLengthPositionX(int segment)
{
    return GetSegmentEndPositionX(segment) - GetSegmentStartPositionX(segment);
}

int RangeTrackAnalyzer::GetSegmentLengthPositionY(int segment)
{
    return GetSegmentEndPositionY(segment) - GetSegmentStartPositionY(segment);
}

int RangeTrackAnalyzer::GetSegmentLengthPositionTheta(int segment)
{
    return GetSegmentEndPositionTheta(segment) - GetSegmentStartPositionTheta(segment);
}

int RangeTrackAnalyzer::GetSegmentStartPointX(int segment)
{
    return m_point_x_positions[m_segments[segment].GetStartIndex()];
}

int RangeTrackAnalyzer::GetSegmentStartPointY(int segment)
{
    return m_point_y_positions[m_segments[segment].GetStartIndex()];
}

int RangeTrackAnalyzer::GetSegmentEndPointX(int segment)
{
    return m_point_x_positions[m_segments[segment].GetEndIndex()];
}

int RangeTrackAnalyzer::GetSegmentEndPointY(int segment)
{
    return m_point_y_positions[m_segments[segment].GetEndIndex()];
}

int RangeTrackAnalyzer::GetSegmentLengthPointX(int segment)
{
    return GetSegmentEndPointX(segment) - GetSegmentStartPointX(segment);
}

int RangeTrackAnalyzer::GetSegmentLengthPointY(int segment)
{
    return GetSegmentEndPointY(segment) - GetSegmentStartPointY(segment);
}

int RangeTrackAnalyzer::GetSegmentLengthPointChord(int segment)
{
    return (int) (sqrt((double)(GetSegmentLengthPointX(segment)*GetSegmentLengthPointX(segment) + GetSegmentLengthPointY(segment)*GetSegmentLengthPointY(segment))));
}

int RangeTrackAnalyzer::GetSegmentLengthPointArc(int segment)
{
    printf("ERROR: GetSegmentLengthArc unimplemented\n");
    return 0;
}

short RangeTrackAnalyzer::GetSegmentMinRange(int segment)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D0 begin
{
    short result = 32000;

    // Calculate minimum
    for(int point = m_segments[segment].GetStartIndex(); point < m_segments[segment].GetEndIndex(); point++)
    {
        if(m_filtered_ranges[point] < result)
            result = m_filtered_ranges[point];
    }

    return(result);
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D0 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

short RangeTrackAnalyzer::GetSegmentMaxRange(int segment)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D2 begin
{
    short result = 0;

    // Calculate maximum
    for(int point = m_segments[segment].GetStartIndex(); point < m_segments[segment].GetEndIndex(); point++)
    {
        if(m_filtered_ranges[point] > result)
            result = m_filtered_ranges[point];
    }

    return(result);
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D2 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

short RangeTrackAnalyzer::GetSegmentMeanRange(int segment)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D4 begin
{
    long long result = 0;

    // Calculate maximum
    for(int point = m_segments[segment].GetStartIndex(); point < m_segments[segment].GetEndIndex(); point++)
    {
        result += m_filtered_ranges[point];
    }

    result /= (m_segments[segment].GetEndIndex() - m_segments[segment].GetStartIndex());

    return result;
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D4 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int RangeTrackAnalyzer::GetSegmentMeanAngleSlope(int segment)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D6 begin
{
    long long result = 0;

    // Calculate maximum
    for(int point = m_segments[segment].GetStartIndex(); point < m_segments[segment].GetEndIndex(); point++)
    {
        result += m_point_angle_slopes[point];
    }

    result /= (m_segments[segment].GetEndIndex() - m_segments[segment].GetStartIndex());

    return result;
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D6 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int RangeTrackAnalyzer::GetSpreadSlope()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D8 begin
{
    return 0;
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010D8 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int RangeTrackAnalyzer::GetMeanConcavity()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010DA begin
{
    return 0;
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010DA end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int RangeTrackAnalyzer::GetSpreadConcavity()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010DC begin
{
    return 0;
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010DC end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int RangeTrackAnalyzer::DumpAnalyze()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000112E begin
{
    return 0;
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000112E end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackAnalyzer::AddWall(double x1, double y1, double x2, double y2)
{
    m_walls_x1.push_back(x1);
    m_walls_y1.push_back(y1);
    m_walls_x2.push_back(x2);
    m_walls_y2.push_back(y2);

    RotateWalls(m_wall_rotation);
}

// rotation will be applied to wall map, only once per wall per rotation operation
void RangeTrackAnalyzer::RotateWalls(double rotation)
{
    m_wall_rotation = rotation;

    m_walls_rotated_x1.resize(m_walls_x1.size());
    m_walls_rotated_y1.resize(m_walls_y1.size());
    m_walls_rotated_x2.resize(m_walls_x2.size());
    m_walls_rotated_y2.resize(m_walls_y2.size());

    for(int wall_index = 0; wall_index < m_walls_x1.size(); wall_index++)
    {
        m_walls_rotated_x1[wall_index] = RotatePointX(m_walls_x1[wall_index], m_walls_y1[wall_index], m_wall_rotation);
        m_walls_rotated_y1[wall_index] = RotatePointY(m_walls_x1[wall_index], m_walls_y1[wall_index], m_wall_rotation);

        m_walls_rotated_x2[wall_index] = RotatePointX(m_walls_x2[wall_index], m_walls_y2[wall_index], m_wall_rotation);
        m_walls_rotated_y2[wall_index] = RotatePointY(m_walls_x2[wall_index], m_walls_y2[wall_index], m_wall_rotation);
    }
}

void RangeTrackAnalyzer::ComputeLocalizationStatsWithAngle(double rotation_init, double rotation_step, double rotation_range, double &out_rotation, double &out_mean_x, double &out_mean_y, double &out_mad_x, double &out_mad_y)
{
    double step_mean_x, step_mean_y, step_mad_x, step_mad_y;
    double best_angle = 0.0, best_mean_x = 0.0, best_mean_y = 0.0, best_mad_x = 1.0e15, best_mad_y = 1.0e15;

    float starttime = seconds();
    float endtime;

    // Convert robot rotation to wall rotation
    rotation_init = -rotation_init;

    // Anticlockwise direction
    for(double angle = rotation_init; angle < rotation_init+rotation_range; angle += rotation_step)
    {
        RotateWalls(angle);
        ComputeLocalizationStats(step_mean_x, step_mean_y, step_mad_x, step_mad_y);

        if(sqrt(step_mad_x*step_mad_x + step_mad_y*step_mad_y) < sqrt(best_mad_x*best_mad_x + best_mad_y*best_mad_y))
        {
            // This rotation is best one we've seen so far

            best_angle = angle;
            best_mean_x = step_mean_x;
            best_mean_y = step_mean_y;
            best_mad_x = step_mad_x;
            best_mad_y = step_mad_y;
        }
    }

    // Clockwise direction
    for(double angle = rotation_init; angle > rotation_init-rotation_range; angle -= rotation_step)
    {
        RotateWalls(angle);
        ComputeLocalizationStats(step_mean_x, step_mean_y, step_mad_x, step_mad_y);

        if(sqrt(step_mad_x*step_mad_x + step_mad_y*step_mad_y) < sqrt(best_mad_x*best_mad_x + best_mad_y*best_mad_y))
        {
            // This rotation is best one we've seen so far

            best_angle = angle;
            best_mean_x = step_mean_x;
            best_mean_y = step_mean_y;
            best_mad_x = step_mad_x;
            best_mad_y = step_mad_y;
        }
    }

    endtime = seconds();
    printf("Angle Localization Time: %f\n", endtime-starttime);

    out_rotation = -best_angle; // convert wall rotation to robot rotation
    out_mean_x = best_mean_x;
    out_mean_y = best_mean_y;
    out_mad_x = best_mad_x;
    out_mad_y = best_mad_y;

}

void RangeTrackAnalyzer::ComputeLocalizationStats(double &out_mean_x, double &out_mean_y, double &out_mad_x, double &out_mad_y)
{
    // ToDo: find mean and M.A.D. for the current rotated walls

    double point_x_correction = 0.0, point_y_correction = 0.0;

    double mean_x_correction = 0.0, mean_y_correction = 0.0;
    double mad_x_correction = 0.0, mad_y_correction = 0.0;

    vector<double> x_corrections;
    vector<double> y_corrections;

    long point_count = 0;

    // Find mean
    for(int point_index = 0; point_index < m_point_x_positions.size(); point_index++)
    {
        if(PointValid(point_index)) // Don't localize using bad points or edges
        {
            VectorToNearestWall( (double) (m_point_x_positions[point_index]) , (double) (m_point_y_positions[point_index]) , point_x_correction, point_y_correction);

            x_corrections.push_back(point_x_correction);
            y_corrections.push_back(point_y_correction);

            mean_x_correction += point_x_correction;
            mean_y_correction += point_y_correction;

            point_count++;
        }
    }

    mean_x_correction /= (double) point_count;
    mean_y_correction /= (double) point_count;

    // Find mad
    for(int point_index = 0; point_index < m_point_x_positions.size(); point_index++)
    {
        if(PointValid(point_index))
        {
            mad_x_correction += abs(x_corrections[point_index] - mean_x_correction);
            mad_y_correction += abs(y_corrections[point_index] - mean_y_correction);
        }
    }

    mad_x_correction /= (double) point_count;
    mad_y_correction /= (double) point_count;

    out_mean_x = mean_x_correction;
    out_mean_y = mean_y_correction;
    out_mad_x = mad_x_correction;
    out_mad_y = mad_y_correction;
}

void RangeTrackAnalyzer::VectorToNearestWall(double point_x, double point_y, double &vector_x, double &vector_y)
{
    double distance = 1.0e30;
    double result_x = 1.0e30, result_y = 1.0e30;

    double temp_distance;
    double temp_result_x, temp_result_y;

    for(int wall_id = 0; wall_id < m_walls_rotated_x1.size(); wall_id++)
    {
        temp_result_x = VectorXPointToSegment(point_x, point_y, m_walls_rotated_x1[wall_id], m_walls_rotated_y1[wall_id], m_walls_rotated_x2[wall_id], m_walls_rotated_y2[wall_id]);
        temp_result_y = VectorYPointToSegment(point_x, point_y, m_walls_rotated_x1[wall_id], m_walls_rotated_y1[wall_id], m_walls_rotated_x2[wall_id], m_walls_rotated_y2[wall_id]);

        temp_distance = sqrt(temp_result_x*temp_result_x + temp_result_y*temp_result_y);

        if(temp_distance < distance)
        {
            distance = temp_distance;
            result_x = temp_result_x;
            result_y = temp_result_y;
        }
    }

    vector_x = result_x;
    vector_y = result_y;
}

// Check signs
double RangeTrackAnalyzer::VectorXPointToSegment(double x, double y, double x1, double y1, double x2, double y2)
{
	double m, b;

	if(Obtuse(PointsToAngle(x1, y1, x2, y2), PointsToAngle(x1, y1, x, y)))
	{
		// distance between (x,y) and (x1, y1)
		//printf("Obtuse 1\n");

		return x1-x; // Distance formula
	}
	else if(Obtuse(PointsToAngle(x2, y2, x1, y1), PointsToAngle(x2, y2, x, y)))
	{
		// distance between (x,y) and (x2, y2)
		//printf("Obtuse 2\n");

		return x2-x; // Distance formula
	}
	else
	{
		// distance between (x,y) and line
		//printf("Both acute\n");

		m = (y2-y1) / (x2-x1);
		b = y1 - m*x1;

		return ((m*y+x-m*b)/(m*m+1)) - x; // http://math.ucsd.edu/~wgarner/math4c/derivations/distance/distptline.htm
	}
}

// Check signs
double RangeTrackAnalyzer::VectorYPointToSegment(double x, double y, double x1, double y1, double x2, double y2)
{
	double m, b;

	if(Obtuse(PointsToAngle(x1, y1, x2, y2), PointsToAngle(x1, y1, x, y)))
	{
		// distance between (x,y) and (x1, y1)
		//printf("Obtuse 1\n");

		return y1-y; // Distance formula
	}
	else if(Obtuse(PointsToAngle(x2, y2, x1, y1), PointsToAngle(x2, y2, x, y)))
	{
		// distance between (x,y) and (x2, y2)
		//printf("Obtuse 2\n");

		return y2-y; // Distance formula
	}
	else
	{
		// distance between (x,y) and line
		//printf("Both acute\n");

		m = (y2-y1) / (x2-x1);
		b = y1 - m*x1;

		return ((m*m*y+m*x+b)/(m*m+1)) - y; // http://math.ucsd.edu/~wgarner/math4c/derivations/distance/distptline.htm
	}
}

int RangeTrackAnalyzer::Obtuse(double angle1, double angle2)
{
	//printf("Obtuse check: %f, %f\n", angle1, angle2);
	return abs(NormalizeAngle(angle2 - angle1)) > (90.0 * 3.14159265 / 180.0);
}

double RangeTrackAnalyzer::PointsToAngle(double x1, double y1, double x2, double y2)
{
	return atan2(y2-y1, x2-x1); // is this reversed?
}

double RangeTrackAnalyzer::NormalizeAngle(double angle)
{
	while(angle > 3.14159265)
	{
		angle -= 2*3.14159265;
	}

	while(angle < -3.14159265)
	{
		angle += 2*3.14159265;
	}

	return angle;
}

double RangeTrackAnalyzer::RotatePointX(double x, double y, double theta)
{
	return x * cos(theta) - y * sin(theta);
}

double RangeTrackAnalyzer::RotatePointY(double x, double y, double theta)
{
	return x * sin(theta) + y * cos(theta);
}
