#include "RangeTrackSegmenter.h"


/*
 */

RangeTrackSegmenter::RangeTrackSegmenter(RangeTrackPositionReader *position_reader_x, RangeTrackPositionReader *position_reader_y, RangeTrackPositionReader *position_reader_theta, RangeTrackRangeReader *range_reader, RangeTrackFilter *range_filter, RangeTrackFilter *slope_filter, RangeTrackFilter *concavity_filter)
: RangeTrackLogger(position_reader_x, position_reader_y, position_reader_theta, range_reader, range_filter, slope_filter, concavity_filter)
{
    SetMinRange(0);
    SetMaxRange(10000);
    SetMinAngle(0);
    SetMaxAngle(0);

    m_process_index = 3; // range starts at 0, filtered range starts at 2, slope angles starts at 3
}

short RangeTrackSegmenter::GetNumSegments()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001151 begin
{
    return(m_segments.size());
}

short RangeTrackSegmenter::GetMinRange()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001151 begin
{
    return(m_min_range);
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001151 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

short RangeTrackSegmenter::GetMaxRange()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001153 begin
{
    return(m_max_range);
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001153 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

long RangeTrackSegmenter::GetMinAngle()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001155 begin
{
    return(m_min_angle);
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001155 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

long RangeTrackSegmenter::GetMaxAngle()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001157 begin
{
    return(m_max_angle);
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001157 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

long RangeTrackSegmenter::GetMinAngleConcavity()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001159 begin
{
    return 0;
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001159 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

long RangeTrackSegmenter::GetMaxAngleConcavity()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000115B begin
{
    return 0;
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000115B end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::SetMinRange(short value)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000115D begin
{
    m_min_range = value;
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000115D end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::SetMaxRange(short value)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000115F begin
{
    m_max_range = value;
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000115F end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::SetMinAngle(long value)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001161 begin
{
    m_min_angle = value;
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001161 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::SetMaxAngle(long value)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001163 begin
{
    m_max_angle = value;
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001163 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::SetMinAngleConcavity(long value)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001169 begin
{
    printf("ERROR: Concavity is unimplemented...\n");
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:0000000000001169 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::SetMaxAngleConcavity(long value)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000116C begin
{
    printf("ERROR: Concavity is unimplemented...\n");
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000116C end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int RangeTrackSegmenter::GetStartIndex(int segment)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010BF begin
{
    return((m_segments[segment]).GetStartIndex());
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010BF end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int RangeTrackSegmenter::GetEndIndex(int segment)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010C2 begin
{
    return((m_segments[segment]).GetEndIndex());
}
// section -64--88-1-7--6b4a04c1:1246524e722:-8000:00000000000010C2 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::UpdateSegment()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7-672b1494:1245fa68a9a:-8000:0000000000000FE1 begin
{
    // all of the data that isn't yet processed
	for(; m_process_index < m_point_angle_concavities.size(); m_process_index++)
	{
		// if we're looking to start a blob
		if(! m_segments.size() || m_segments[m_segments.size()-1].GetClosed())
		{
			// If point fits the restrictions on being part of a Segment
			if(PointValid(m_process_index))
			{
			    // This code is probably useless... maybe I'll revisit it later.
			    /*
			    if(PointDistance(m_segments[m_segments.size()-1].GetEndIndex, m_process_index) < m_segment_tolerance)
			    {
			    }
			    */

				// mark the blob as started
				m_segments.push_back(*(new RangeTrackSegmentData()));

				// mark the current index as the start and end... should we actually do the end?
				m_segments[m_segments.size()-1].SetStartIndex(m_process_index);

				continue;
			}
		}
		// If we're already tracking a blob
		else
		{
			// Point is not part of segment; we've found a blob boundary
			if(! PointValid(m_process_index))
			{
				m_segments[m_segments.size()-1].SetClosed(true);
				// -1 because we're already 1 reading outside the blob
				m_segments[m_segments.size()-1].SetEndIndex(m_process_index-1);
			}
			else
			{
			    m_segments[m_segments.size()-1].SetEndIndex(m_process_index);
			}
		}
	}
}
// section -64--88-1-7-672b1494:1245fa68a9a:-8000:0000000000000FE1 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool RangeTrackSegmenter::PointValid(int index)
{
	long angle;


	// If we're too close or too far, point is invalid (maybe we're outside of the ET's accurate range)
	if(m_filtered_ranges[index] < m_min_range)
		return false;
	if(m_filtered_ranges[index] > m_max_range)
		return false;

	// Calculate angle
	angle = m_point_angle_slopes[index] - m_theta_positions[index];

	// Normalize angle
	while(angle > 3142)
		angle -= 6283;
	while(angle < -3142)
		angle += 6283;

	// If we're at a very sharp angle (near parallel to line of sight), point is invalid (most likely an edge between objects)
	//if(angle < m_min_angle || angle > m_max_angle)
	if(angle > m_min_angle && angle < m_max_angle)
	{
		// very small fluctuations could trigger strong angles... a better solution to this problem is to merge segments in post-processing.
		//if(abs(m_filtered_ranges[index] - m_filtered_ranges[index-1]) > m_range_tolerance)

		return false;
	}

	return true;
}

void RangeTrackSegmenter::UpdateAll()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7-672b1494:1245fa68a9a:-8000:0000000000000FE3 begin
{
    RangeTrackLogger::UpdateAll();
    UpdateSegment();
}
// section -64--88-1-7-672b1494:1245fa68a9a:-8000:0000000000000FE3 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::Reset()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-7--6fa0052a:12469e52649:-8000:000000000000112D begin
{
    m_segments.clear();

    m_process_index = 3; // range starts at 0, filtered range starts at 2, slope angles starts at 3

    RangeTrackLogger::Reset();
}
// section -64--88-1-7--6fa0052a:12469e52649:-8000:000000000000112D end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void RangeTrackSegmenter::DumpSegment(const char filename[])
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000112A begin
{
    int segment = 0;
    int index = 0;

	FILE *outFile = fopen(filename, "w");

	//fprintf(outFile, "Range Data\n\n");
	//fprintf(outFile, "Angle, Range\n");

	fprintf(outFile, "Bot X, Bot Y, Bot Theta, Range, Range Filtered, Point X, Point Y, Point Angle Slope, Point Angle Concavity, Segment ID\n");

    for(segment = 0; segment < m_segments.size(); segment++)
    {

        for(index=m_segments[segment].GetStartIndex(); index<m_segments[segment].GetEndIndex(); index++)
        {
            fprintf(outFile, "%d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n", m_x_positions[index], m_y_positions[index], m_theta_positions[index], m_ranges[index], m_filtered_ranges[index], m_point_x_positions[index], m_point_y_positions[index], m_point_angle_slopes[index], m_point_angle_concavities[index], segment);
        }
        fprintf(outFile, " , , , , , , , , , \n");

    }

	fclose (outFile);
}
// section -64--88-1-8-45c899e5:124a28211a8:-8000:000000000000112A end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

